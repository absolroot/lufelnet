name: Fetch external JSON every 6h

on:
  schedule:
    - cron: "0 */6 * * *"   # 6시간마다 (UTC)
  workflow_dispatch: {}      # 필요 시 수동 실행

permissions:
  contents: write

concurrency:
  group: fetch-external-json
  cancel-in-progress: false

jobs:
  fetch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch & update JSON files
        env:
          BASE_URL: https://iant.kr:5000/data
        run: |
          # [중요] 에러가 발생해도 스크립트가 멈추지 않도록 설정 (set +e)
          set +e
          # 파이프라인 에러도 무시 (set +o pipefail)
          set +o pipefail
          
          # 변수 미설정 시에만 에러 발생
          set -u

          # 저장 루트 설정
          ROOT_DIR="data/external"
          mkdir -p "$ROOT_DIR/gacha" "$ROOT_DIR/guildboss" "$ROOT_DIR/sos" "$ROOT_DIR/sandbox"
          mkdir -p "$ROOT_DIR/character" "$ROOT_DIR/weapon"
          mkdir -p "$ROOT_DIR/before"
          mkdir -p "$ROOT_DIR/before/character" "$ROOT_DIR/before/weapon" "$ROOT_DIR/before/sandbox"

          ENDPOINTS=("gacha" "guildboss" "sos" "sandbox")
          REGIONS=("kr" "en" "cn" "tw" "jp" "sea")
          CODENAME_FILE="${ROOT_DIR}/character/codename.json"

          changed=0

          # [수정됨] 쉘 이스케이프 문제를 해결한 강력한 Python 정화 함수
          # 홑따옴표(')를 사용하여 YAML/Shell이 역슬래시(\)를 먹어버리는 것을 방지
          clean_json() {
            python3 -c 'import sys, re; s = sys.stdin.read(); sys.stdout.write(re.sub(r"([:\[,]\s*)0+([1-9])", r"\1\2", s))'
          }

          fetch_and_write () {
            local endpoint="$1"
            local region="$2"
            local url="${BASE_URL}/${endpoint}/${region}?source=lufelnet"
            local out="${ROOT_DIR}/${endpoint}/${region}.json"
            local backup_dir="${ROOT_DIR}/before/${endpoint}"
            local timestamp=$(date +"%Y%m%d_%H%M%S")
            local backup_file="${backup_dir}/${region}_${timestamp}.json"

            echo "➡️  Fetching: ${url}"

            tmp_raw="$(mktemp)"
            tmp_clean="$(mktemp)"

            # 1. 다운로드 (실패 시 함수 종료, 스크립트는 계속)
            curl -sS "$url" -o "$tmp_raw"
            if [ $? -ne 0 ]; then
               echo "⚠️ Download failed. Skipping..."
               return
            fi

            # 2. 정화 작업 (Python)
            cat "$tmp_raw" | clean_json > "$tmp_clean"

            # 3. 유효성 검사 (에러나면 건너뜀)
            jq . "$tmp_clean" > /dev/null 2>&1
            if [ $? -ne 0 ]; then
               echo "⚠️ Invalid JSON detected in ${endpoint}/${region}. Skipping update."
               # 디버깅: 왜 에러났는지 앞부분만 출력해봄
               echo "   --- Broken Content Snippet ---"
               head -c 100 "$tmp_clean"
               echo "   ------------------------------"
               return
            fi
            
            # 4. 정렬
            jq -S . "$tmp_clean" > "${tmp_clean}.sorted"

            # 5. 변경 확인 및 저장
            if [ -f "$out" ]; then
              tmp_old="$(mktemp)"
              jq -S . "$out" > "$tmp_old"
              if diff -q "$tmp_old" "${tmp_clean}.sorted" > /dev/null; then
                echo "   No change."
              else
                cp "$out" "$backup_file"
                cp "${tmp_clean}.sorted" "$out"
                echo "   Updated."
                changed=1
              fi
            else
              cp "${tmp_clean}.sorted" "$out"
              echo "   Created."
              changed=1
            fi
          }

          fetch_and_write_character () {
            local region="$1"
            local api_codename="$2"
            local local_codename="$3"
            local url="${BASE_URL}/character/${region}/${api_codename}?source=lufelnet"
            local out="${ROOT_DIR}/character/${region}/${local_codename}.json"
            local backup_dir="${ROOT_DIR}/before/character/${region}"
            local timestamp=$(date +"%Y%m%d_%H%M%S")
            local backup_file="${backup_dir}/${local_codename}_${timestamp}.json"

            echo "➡️  Fetching: ${url}"

            tmp_raw="$(mktemp)"
            tmp_clean="$(mktemp)"

            # 1. 다운로드
            curl -sS "$url" -o "$tmp_raw"
            if [ $? -ne 0 ]; then
               echo "⚠️ Download failed. Skipping..."
               return
            fi
            
            # 2. 정화
            cat "$tmp_raw" | clean_json > "$tmp_clean"

            # 3. 유효성 검사
            jq . "$tmp_clean" > /dev/null 2>&1
            if [ $? -ne 0 ]; then
               # 에러지만 '데이터 없음(status 100)'인 경우는 정상 처리로 간주하고 로그만 남김
               if grep -q '"status": 100' "$tmp_clean" || grep -q '"status":100' "$tmp_clean"; then
                   echo "   Character not found (API status 100). Skipping."
               else
                   echo "⚠️ Invalid JSON detected. Skipping update for: $local_codename"
               fi
               return
            fi

            # 데이터 null 체크
            if jq -e '.status == 100 and .data == null' "$tmp_clean" > /dev/null 2>&1; then
              echo "   Data is null. Skipping."
              return
            fi

            # 4. 정렬 및 저장
            jq -S . "$tmp_clean" > "${tmp_clean}.sorted"

            mkdir -p "$(dirname "$out")"
            mkdir -p "$backup_dir"

            if [ -f "$out" ]; then
              tmp_old="$(mktemp)"
              jq -S . "$out" > "$tmp_old"
              if diff -q "$tmp_old" "${tmp_clean}.sorted" > /dev/null; then
                echo "   No change."
              else
                cp "$out" "$backup_file"
                cp "${tmp_clean}.sorted" "$out"
                echo "   Updated: $local_codename"
                changed=1
              fi
            else
              cp "${tmp_clean}.sorted" "$out"
              echo "   Created: $local_codename"
              changed=1
            fi
          }

          fetch_and_write_weapon () {
            local region="$1"
            local api_codename="$2"
            local local_codename="$3"
            local url="${BASE_URL}/weapon/${region}/${api_codename}?source=lufelnet"
            local out="${ROOT_DIR}/weapon/${region}/${local_codename}.json"
            local backup_dir="${ROOT_DIR}/before/weapon/${region}"
            local timestamp=$(date +"%Y%m%d_%H%M%S")
            local backup_file="${backup_dir}/${local_codename}_${timestamp}.json"

            echo "➡️  Fetching: ${url}"

            tmp_raw="$(mktemp)"
            tmp_clean="$(mktemp)"

            curl -sS "$url" -o "$tmp_raw"
            if [ $? -ne 0 ]; then
               echo "⚠️ Download failed. Skipping..."
               return
            fi
            
            cat "$tmp_raw" | clean_json > "$tmp_clean"

            jq . "$tmp_clean" > /dev/null 2>&1
            if [ $? -ne 0 ]; then
               echo "⚠️ Invalid JSON detected. Skipping update for weapon: $local_codename"
               return
            fi

            if jq -e 'has("error")' "$tmp_clean" > /dev/null 2>&1; then
              echo "   Weapon not found (API error). Skipping."
              return
            fi

            jq -S . "$tmp_clean" > "${tmp_clean}.sorted"

            mkdir -p "$(dirname "$out")"
            mkdir -p "$backup_dir"

            if [ -f "$out" ]; then
              tmp_old="$(mktemp)"
              jq -S . "$out" > "$tmp_old"
              if diff -q "$tmp_old" "${tmp_clean}.sorted" > /dev/null; then
                echo "   No change."
              else
                cp "$out" "$backup_file"
                cp "${tmp_clean}.sorted" "$out"
                echo "   Updated: $local_codename"
                changed=1
              fi
            else
              cp "${tmp_clean}.sorted" "$out"
              echo "   Created: $local_codename"
              changed=1
            fi
          }

          # 메인 실행 루프
          for ep in "${ENDPOINTS[@]}"; do
            for rg in "${REGIONS[@]}"; do
              fetch_and_write "$ep" "$rg"
            done
          done

          if [ -f "$CODENAME_FILE" ]; then
            echo "➡️  Loading codenames mapping from: $CODENAME_FILE"
            # mapfile이 실패해도 멈추지 않도록 처리
            mapfile -t CN_API < <(jq -r '.[].api' "$CODENAME_FILE" || echo "")
            mapfile -t CN_LOCAL < <(jq -r '.[].local' "$CODENAME_FILE" || echo "")
            
            if [ ${#CN_API[@]} -eq 0 ]; then
                echo "⚠️  Failed to parse codename file or empty. Skipping characters."
            else
                for rg in "${REGIONS[@]}"; do
                  mkdir -p "$ROOT_DIR/character/$rg" "$ROOT_DIR/weapon/$rg"
                  mkdir -p "$ROOT_DIR/before/character/$rg" "$ROOT_DIR/before/weapon/$rg"
                  for i in "${!CN_API[@]}"; do
                    api_code="${CN_API[$i]}"
                    local_code="${CN_LOCAL[$i]}"
                    # 빈 줄 체크
                    if [ -n "$api_code" ]; then
                        fetch_and_write_character "$rg" "$api_code" "$local_code"
                        fetch_and_write_weapon "$rg" "$api_code" "$local_code"
                    fi
                  done
                done
            fi
          else
            echo "⚠️  $CODENAME_FILE not found. Skip character fetch."
          fi

          # 변경 사항 커밋
          if [ "$changed" -eq 1 ] || ! git diff --quiet; then
            git config user.name  "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add -A || true
            git commit -m "chore(data): update /data/external JSONs [skip ci]" || echo "ℹ️ No new commits created."
            git push || echo "ℹ️ Nothing to push or push skipped."
            echo "✅ Commit/push step completed."
          else
            echo "✅ No changes to commit."
          fi
          
          # [중요] 마지막엔 항상 성공 코드(0)로 종료하여 Actions이 빨간불 뜨지 않게 함
          exit 0